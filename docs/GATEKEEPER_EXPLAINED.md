# macOS Gatekeeper 隔离机制说明

## 为什么开发者自己的设备可以正常打开,其他设备不行?

### 核心原因: Quarantine 隔离属性

macOS 使用"隔离属性"(Quarantine)来标记从互联网下载的文件。

## 三种情况对比

### 1. 开发者本地编译 ✅
```bash
# 你的设备上
npm run build:mac
# 生成的文件没有隔离属性
# macOS 认为这是"本地创建"的文件
# 可以直接打开,无需验证
```

**为什么能打开?**
- 文件是本地创建的
- 没有 `com.apple.quarantine` 扩展属性
- Gatekeeper 不会严格检查

### 2. 通过互联网下载 ❌
```bash
# 其他用户下载你的应用
# macOS 自动添加隔离属性:
xattr Doit.app
# com.apple.quarantine: 0083;65a1b2c3;Safari;...
```

**为什么被阻止?**
- 文件有隔离属性
- Gatekeeper 严格检查签名
- 发现是 ad-hoc 签名(未经 Apple 认证)
- 显示"已损坏"或"无法验证开发者"

### 3. 通过 USB/AirDrop 传输 ⚠️
```bash
# 取决于传输方式
# USB: 通常不会添加隔离属性 ✅
# AirDrop: 可能会添加隔离属性 ❌
# 网盘下载: 会添加隔离属性 ❌
```

## 验证方法

### 检查文件是否有隔离属性
```bash
# 在你的设备上
xattr /Applications/Doit.app

# 如果输出为空 → 没有隔离属性 → 可以打开
# 如果有 com.apple.quarantine → 有隔离属性 → 会被阻止
```

### 移除隔离属性
```bash
# 这就是为什么这个命令有效
xattr -cr /Applications/Doit.app
# -c: clear 清除所有扩展属性
# -r: recursive 递归处理所有文件
```

## 完整的安全检查流程

```
文件来源 → 是否有隔离属性?
           ↓
        有隔离属性
           ↓
    Gatekeeper 检查签名
           ↓
    ┌──────┴──────┐
    ↓             ↓
有效签名      ad-hoc签名
    ↓             ↓
  允许打开      阻止打开
              (显示"已损坏")
```

## 实际场景

| 场景 | 隔离属性 | 能否打开 | 原因 |
|------|----------|----------|------|
| 本地编译 | ❌ 无 | ✅ 能 | 本地文件,不检查 |
| Safari 下载 | ✅ 有 | ❌ 不能 | 严格检查签名 |
| Chrome 下载 | ✅ 有 | ❌ 不能 | 严格检查签名 |
| USB 拷贝 | ❌ 无 | ✅ 能 | 不添加隔离属性 |
| 百度网盘下载 | ✅ 有 | ❌ 不能 | 下载会添加属性 |
| 微信传输 | ⚠️ 可能有 | ⚠️ 不确定 | 取决于版本 |

## 解决方案优先级

### 方案 1: 用户手动移除隔离属性 ⭐⭐⭐⭐⭐
```bash
xattr -cr /Applications/Doit.app
```
- **优点**: 简单有效,一次性解决
- **缺点**: 需要用户执行命令

### 方案 2: 右键打开 ⭐⭐⭐⭐
- **优点**: 不需要命令行
- **缺点**: 首次需要额外操作

### 方案 3: 购买开发者证书 ⭐⭐⭐
- **优点**: 用户体验最好
- **缺点**: $99/年,需要公司/个人信息

### 方案 4: 通过 USB 分发 ⭐⭐
- **优点**: 不会添加隔离属性
- **缺点**: 不适合大规模分发

## 技术细节

### Gatekeeper 检查顺序
1. 检查是否有 `com.apple.quarantine` 属性
2. 如果有,检查代码签名
3. 检查签名是否来自已识别的开发者
4. 检查是否经过公证(Notarization)
5. 如果任何一步失败,阻止运行

### 为什么本地文件不检查?
- macOS 假设本地创建的文件是安全的
- 只对"外来"文件进行严格检查
- 这是性能和安全的平衡

## 总结

**你的设备能打开** = 本地编译,无隔离属性,Gatekeeper 不检查  
**其他设备不能打开** = 下载获得,有隔离属性,Gatekeeper 严格检查 ad-hoc 签名

这不是你的应用有问题,而是 macOS 的安全机制在起作用!
